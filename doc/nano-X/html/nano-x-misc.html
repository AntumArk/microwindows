<HTML
><HEAD
><TITLE
>misc</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.59"><LINK
REL="HOME"
TITLE="Nano-X API Reference Manual"
HREF="index.html"><LINK
REL="UP"
TITLE="libnano-X"
HREF="libnano-x.html"><LINK
REL="PREVIOUS"
TITLE="selections"
HREF="nano-x-selections.html"></HEAD
><BODY
CLASS="REFENTRY"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
BGCOLOR="#000000"
CELLPADDING="1"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
><FONT
COLOR="#FFFFFF"
SIZE="5"
>Nano-X API Reference Manual</FONT
></TH
></TR
><TR
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="left"
><A
HREF="nano-x-selections.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>&#60;&#60;&#60; Previous Page</B
></FONT
></A
></TD
><TD
WIDTH="25%"
BGCOLOR="#0000C0"
ALIGN="center"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
><A
HREF="index.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Home</B
></FONT
></A
></B
></FONT
></TD
><TD
WIDTH="25%"
BGCOLOR="#00C000"
ALIGN="center"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
><A
HREF="libnano-x.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Up</B
></FONT
></A
></B
></FONT
></TD
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="right"
>&nbsp;</TD
></TR
></TABLE
></DIV
><H1
><A
NAME="NANO-X-MISC"
>misc</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN3516"
></A
><H2
>Name</H2
>misc&nbsp;--&nbsp;</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN3519"
></A
><H2
>Synopsis</H2
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>&#13;

void        <A
HREF="nano-x-misc.html#GRREQSHMCMDS"
>GrReqShmCmds</A
>                    (<GTKDOCLINK
HREF="LONG"
>long</GTKDOCLINK
> shmsize);
void        <A
HREF="nano-x-misc.html#GRINJECTKEYBOARDEVENT"
>GrInjectKeyboardEvent</A
>           (<GTKDOCLINK
HREF="GR-WINDOW-ID-CAPS"
>GR_WINDOW_ID</GTKDOCLINK
> wid,
                                             <GTKDOCLINK
HREF="GR-KEY-CAPS"
>GR_KEY</GTKDOCLINK
> keyvalue,
                                             <GTKDOCLINK
HREF="GR-KEYMOD-CAPS"
>GR_KEYMOD</GTKDOCLINK
> modifier,
                                             <GTKDOCLINK
HREF="GR-SCANCODE-CAPS"
>GR_SCANCODE</GTKDOCLINK
> scancode,
                                             <GTKDOCLINK
HREF="GR-BOOL-CAPS"
>GR_BOOL</GTKDOCLINK
> pressed);
void        <A
HREF="nano-x-misc.html#GRREGISTERINPUT"
>GrRegisterInput</A
>                 (int fd);
void        <A
HREF="nano-x-misc.html#GRPREPARESELECT"
>GrPrepareSelect</A
>                 (int *maxfd,
                                             void *rfdset);
void        <A
HREF="nano-x-misc.html#GRSERVICESELECT"
>GrServiceSelect</A
>                 (void *rfdset,
                                             <GTKDOCLINK
HREF="GR-FNCALLBACKEVENT-CAPS"
>GR_FNCALLBACKEVENT</GTKDOCLINK
> fncb);
void        <A
HREF="nano-x-misc.html#GRBELL"
>GrBell</A
>                          (void);
void        <A
HREF="nano-x-misc.html#GRSETSCREENSAVERTIMEOUT"
>GrSetScreenSaverTimeout</A
>         (<GTKDOCLINK
HREF="GR-TIMEOUT-CAPS"
>GR_TIMEOUT</GTKDOCLINK
> timeout);
void        <A
HREF="nano-x-misc.html#GRQUERYTREE"
>GrQueryTree</A
>                     (<GTKDOCLINK
HREF="GR-WINDOW-ID-CAPS"
>GR_WINDOW_ID</GTKDOCLINK
> wid,
                                             <GTKDOCLINK
HREF="GR-WINDOW-ID-CAPS"
>GR_WINDOW_ID</GTKDOCLINK
> *parentid,
                                             <GTKDOCLINK
HREF="GR-WINDOW-ID-CAPS"
>GR_WINDOW_ID</GTKDOCLINK
> **children,
                                             <GTKDOCLINK
HREF="GR-COUNT-CAPS"
>GR_COUNT</GTKDOCLINK
> *nchildren);
void        <A
HREF="nano-x-misc.html#GRSETPORTRAITMODE"
>GrSetPortraitMode</A
>               (int portraitmode);
void        <A
HREF="nano-x-misc.html#GRCHANGEPROPERTY"
>GrChangeProperty</A
>                (<GTKDOCLINK
HREF="GR-WINDOW-ID-CAPS"
>GR_WINDOW_ID</GTKDOCLINK
> wid,
                                             <GTKDOCLINK
HREF="GR-CHAR-CAPS"
>GR_CHAR</GTKDOCLINK
> *property,
                                             <GTKDOCLINK
HREF="GR-PROP-CAPS"
>GR_PROP</GTKDOCLINK
> *data,
                                             <GTKDOCLINK
HREF="GR-COUNT-CAPS"
>GR_COUNT</GTKDOCLINK
> len);
<GTKDOCLINK
HREF="GR-COUNT-CAPS"
>GR_COUNT</GTKDOCLINK
>    <A
HREF="nano-x-misc.html#GRGETWINDOWPROPERTY"
>GrGetWindowProperty</A
>             (<GTKDOCLINK
HREF="GR-WINDOW-ID-CAPS"
>GR_WINDOW_ID</GTKDOCLINK
> wid,
                                             <GTKDOCLINK
HREF="GR-CHAR-CAPS"
>GR_CHAR</GTKDOCLINK
> *property,
                                             <GTKDOCLINK
HREF="GR-PROP-CAPS"
>GR_PROP</GTKDOCLINK
> **data);
<GTKDOCLINK
HREF="GR-TIMER-ID-CAPS"
>GR_TIMER_ID</GTKDOCLINK
> <A
HREF="nano-x-misc.html#GRCREATETIMER"
>GrCreateTimer</A
>                   (<GTKDOCLINK
HREF="GR-WINDOW-ID-CAPS"
>GR_WINDOW_ID</GTKDOCLINK
> wid,
                                             <GTKDOCLINK
HREF="GR-TIMEOUT-CAPS"
>GR_TIMEOUT</GTKDOCLINK
> period,
                                             <GTKDOCLINK
HREF="GR-BOOL-CAPS"
>GR_BOOL</GTKDOCLINK
> periodic);
void        <A
HREF="nano-x-misc.html#GRDESTROYTIMER"
>GrDestroyTimer</A
>                  (<GTKDOCLINK
HREF="GR-TIMER-ID-CAPS"
>GR_TIMER_ID</GTKDOCLINK
> tid);</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN3560"
></A
><H2
>Description</H2
><P
></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN3563"
></A
><H2
>Details</H2
><DIV
CLASS="REFSECT2"
><A
NAME="AEN3565"
></A
><H3
><A
NAME="GRREQSHMCMDS"
></A
>GrReqShmCmds ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        GrReqShmCmds                    (<GTKDOCLINK
HREF="LONG"
>long</GTKDOCLINK
> shmsize);</PRE
></TD
></TR
></TABLE
><P
>Requests a shared memory area of the specified size to use for transferring
command arguments. This is faster but less portable than the standard BSD
sockets method of communication (and of course will only work if the client
and server are on the same machine). Apart from the initial allocation of
the area using this call, the use of shared memory is completely
transparent. Additionally, if the allocation fails we silently and
automatically fall back on socket communication. It is safe to call this
function even if shared memory support is not compiled in; it will simply
do nothing.</P
><P
>FIXME: how does the user decide what size of shared memory area to allocate?</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN3573"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>shmsize</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the size of the shared memory area to allocate</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN3582"
></A
><H3
><A
NAME="GRINJECTKEYBOARDEVENT"
></A
>GrInjectKeyboardEvent ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        GrInjectKeyboardEvent           (<GTKDOCLINK
HREF="GR-WINDOW-ID-CAPS"
>GR_WINDOW_ID</GTKDOCLINK
> wid,
                                             <GTKDOCLINK
HREF="GR-KEY-CAPS"
>GR_KEY</GTKDOCLINK
> keyvalue,
                                             <GTKDOCLINK
HREF="GR-KEYMOD-CAPS"
>GR_KEYMOD</GTKDOCLINK
> modifier,
                                             <GTKDOCLINK
HREF="GR-SCANCODE-CAPS"
>GR_SCANCODE</GTKDOCLINK
> scancode,
                                             <GTKDOCLINK
HREF="GR-BOOL-CAPS"
>GR_BOOL</GTKDOCLINK
> pressed);</PRE
></TD
></TR
></TABLE
><P
>Sends a keyboard event to the specified window, or to the window with the
current keyboard focus if 0 is used as the ID. The other arguments
correspond directly to the fields of the same names in the keyboard event
structure.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN3593"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>wid</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> ID of the window to send the event to, or 0</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>keyvalue</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the value of the key event to inject</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>modifier</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> modifiers (shift, ctrl, alt, etc.) to inject</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>scancode</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the scancode of the key event to inject</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>pressed</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> whether to inject a key pressed or key released event</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN3618"
></A
><H3
><A
NAME="GRREGISTERINPUT"
></A
>GrRegisterInput ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        GrRegisterInput                 (int fd);</PRE
></TD
></TR
></TABLE
><P
>Register an extra file descriptor to monitor in the main <GTKDOCLINK
HREF="SELECT"
>select</GTKDOCLINK
>() call.
An event will be returned when the fd has data waiting to be read if that
event has been selected for.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN3625"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>fd</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the file descriptor to monitor</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN3634"
></A
><H3
><A
NAME="GRPREPARESELECT"
></A
>GrPrepareSelect ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        GrPrepareSelect                 (int *maxfd,
                                             void *rfdset);</PRE
></TD
></TR
></TABLE
><P
>Prepare for a GrServiceSelect function by asking the server to send the next
event but not waiting around for it to arrive and initialising the
specified fd_set structure with the client/server socket descriptor and any
previously registered external file descriptors. Also compares the current
contents of maxfd, the client/server socket descriptor, and the previously
registered external file descriptors, and returns the highest of them in
maxfd.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN3640"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>maxfd</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> pointer to a variable which the highest in use fd will be written to</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>rfdset</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> pointer to the file descriptor set structure to use</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN3653"
></A
><H3
><A
NAME="GRSERVICESELECT"
></A
>GrServiceSelect ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        GrServiceSelect                 (void *rfdset,
                                             <GTKDOCLINK
HREF="GR-FNCALLBACKEVENT-CAPS"
>GR_FNCALLBACKEVENT</GTKDOCLINK
> fncb);</PRE
></TD
></TR
></TABLE
><P
>Used by <A
HREF="nano-x-general.html#GRMAINLOOP"
>GrMainLoop</A
>() to call the specified callback function when an
event arrives or there is data waiting on an external fd specified by
<A
HREF="nano-x-misc.html#GRREGISTERINPUT"
>GrRegisterInput</A
>().</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN3662"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>rfdset</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> pointer to the file descriptor set to monitor</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>fncb</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> pointer to the function to call when an event needs handling</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN3675"
></A
><H3
><A
NAME="GRBELL"
></A
>GrBell ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        GrBell                          (void);</PRE
></TD
></TR
></TABLE
><P
>Asks the server to ring the console bell on behalf of the client (intended
for terminal apps to be able to ring the bell on the server even if they
are running remotely).</P
><P
></P
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN3681"
></A
><H3
><A
NAME="GRSETSCREENSAVERTIMEOUT"
></A
>GrSetScreenSaverTimeout ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        GrSetScreenSaverTimeout         (<GTKDOCLINK
HREF="GR-TIMEOUT-CAPS"
>GR_TIMEOUT</GTKDOCLINK
> timeout);</PRE
></TD
></TR
></TABLE
><P
>Sets the number of seconds of inactivity before a screen saver activate
event is sent to the root window ID. A value of 0 activates the
screen saver immediately, and a value of -1 disables the screen saver
function.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN3688"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>timeout</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the number of seconds of inactivity before screen saver activates</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN3697"
></A
><H3
><A
NAME="GRQUERYTREE"
></A
>GrQueryTree ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        GrQueryTree                     (<GTKDOCLINK
HREF="GR-WINDOW-ID-CAPS"
>GR_WINDOW_ID</GTKDOCLINK
> wid,
                                             <GTKDOCLINK
HREF="GR-WINDOW-ID-CAPS"
>GR_WINDOW_ID</GTKDOCLINK
> *parentid,
                                             <GTKDOCLINK
HREF="GR-WINDOW-ID-CAPS"
>GR_WINDOW_ID</GTKDOCLINK
> **children,
                                             <GTKDOCLINK
HREF="GR-COUNT-CAPS"
>GR_COUNT</GTKDOCLINK
> *nchildren);</PRE
></TD
></TR
></TABLE
><P
>Return the ID of the specified windows parent window and a list of the IDs
of all its child windows. It is the callers responsibility to free the
list of child windows when it is no longer required. On failure, the
children pointer will be set to NULL.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN3707"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>wid</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the window ID to start the tree from</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>parentid</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> pointer to a variable to return the parent ID in</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>children</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> pointer to a pointer to put the returned child window ID list in</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>nchildren</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> pointer to a variable to put the returned child window count in</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN3728"
></A
><H3
><A
NAME="GRSETPORTRAITMODE"
></A
>GrSetPortraitMode ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        GrSetPortraitMode               (int portraitmode);</PRE
></TD
></TR
></TABLE
><P
>Changes the orientation of the screen. The four possible values are
GR_PORTRAIT_NONE (no rotation), GR_PORTRAIT_LEFT (rotate left),
GR_PORTRAIT_RIGHT (rotate right), and GR_PORTRAIT_DOWN (upside down).
The window is automatically redrawn after changing the portrait mode.
The current portrait mode can be discovered by retrieving the screeninfo
structure using the  <A
HREF="nano-x-general.html#GRGETSCREENINFO"
>GrGetScreenInfo</A
>() call, and looking at the value of
the portrait member.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN3735"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>portraitmode</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the value to set the portrait mode to</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN3744"
></A
><H3
><A
NAME="GRCHANGEPROPERTY"
></A
>GrChangeProperty ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        GrChangeProperty                (<GTKDOCLINK
HREF="GR-WINDOW-ID-CAPS"
>GR_WINDOW_ID</GTKDOCLINK
> wid,
                                             <GTKDOCLINK
HREF="GR-CHAR-CAPS"
>GR_CHAR</GTKDOCLINK
> *property,
                                             <GTKDOCLINK
HREF="GR-PROP-CAPS"
>GR_PROP</GTKDOCLINK
> *data,
                                             <GTKDOCLINK
HREF="GR-COUNT-CAPS"
>GR_COUNT</GTKDOCLINK
> len);</PRE
></TD
></TR
></TABLE
><P
>Changes the data stored in the specified property attached to the
specified window. If the property does not already exist, it will be
created. The property name should be a zero terminated string. To
create a global property, attach it the root window
(GR_ROOT_WINDOW_ID). If data is a null pointer but len is &gt;= 1, the
property is created with no data block attached to it. If len is 0,
the property is deleted.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN3754"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>wid</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the ID of the window the property is attached to</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>property</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the name of the property</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>data</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the data to be stored in the property</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>len</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the length of the data to be stored in the property</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN3775"
></A
><H3
><A
NAME="GRGETWINDOWPROPERTY"
></A
>GrGetWindowProperty ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><GTKDOCLINK
HREF="GR-COUNT-CAPS"
>GR_COUNT</GTKDOCLINK
>    GrGetWindowProperty             (<GTKDOCLINK
HREF="GR-WINDOW-ID-CAPS"
>GR_WINDOW_ID</GTKDOCLINK
> wid,
                                             <GTKDOCLINK
HREF="GR-CHAR-CAPS"
>GR_CHAR</GTKDOCLINK
> *property,
                                             <GTKDOCLINK
HREF="GR-PROP-CAPS"
>GR_PROP</GTKDOCLINK
> **data);</PRE
></TD
></TR
></TABLE
><P
>Searches for a property with the specified name in the list of
properties attached to the specified window and returns the data
block associated with the property. If no such property is found, the
length is zero and the a null pointer is stored in the data pointer.
If the property exists but no data block is associated with it, 1 is
returned for the length and the data pointer is set to NULL. The data
block is allocated with <GTKDOCLINK
HREF="MALLOC"
>malloc</GTKDOCLINK
>() at call time, and it is the callers
responsibility to free it when no longer needed. If the <GTKDOCLINK
HREF="MALLOC"
>malloc</GTKDOCLINK
>() call
fails the data pointer will be set to null.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN3787"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>wid</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the ID of the window the property is attached to</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>property</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the name of the property</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>data</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> pointer to a pointer to hold the address of the returned data</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><I
CLASS="EMPHASIS"
>Returns</I
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the length of the returned data block</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN3808"
></A
><H3
><A
NAME="GRCREATETIMER"
></A
>GrCreateTimer ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><GTKDOCLINK
HREF="GR-TIMER-ID-CAPS"
>GR_TIMER_ID</GTKDOCLINK
> GrCreateTimer                   (<GTKDOCLINK
HREF="GR-WINDOW-ID-CAPS"
>GR_WINDOW_ID</GTKDOCLINK
> wid,
                                             <GTKDOCLINK
HREF="GR-TIMEOUT-CAPS"
>GR_TIMEOUT</GTKDOCLINK
> period,
                                             <GTKDOCLINK
HREF="GR-BOOL-CAPS"
>GR_BOOL</GTKDOCLINK
> periodic);</PRE
></TD
></TR
></TABLE
><P
>Creates a new timer which will generate a GR_EVENT_TYPE_TIMER event after
the specified period. The timer can be destroyed before it expires if
required using the <A
HREF="nano-x-misc.html#GRDESTROYTIMER"
>GrDestroyTimer</A
>() call. If you want to make a timer which
will keep generating events every period ms instead of generating a single
event, set periodic to GR_TRUE instead of GR_FALSE.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN3819"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>wid</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the ID of the window the timeout event should be delivered to</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>period</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the period in ms before the timer should expire</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>periodic</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> if true, make a periodic timer instead of a one shot</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><I
CLASS="EMPHASIS"
>Returns</I
> :</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the ID of the timer</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><HR><DIV
CLASS="REFSECT2"
><A
NAME="AEN3840"
></A
><H3
><A
NAME="GRDESTROYTIMER"
></A
>GrDestroyTimer ()</H3
><TABLE
BORDER="0"
BGCOLOR="#D6E8FF"
WIDTH="100%"
CELLPADDING="6"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>void        GrDestroyTimer                  (<GTKDOCLINK
HREF="GR-TIMER-ID-CAPS"
>GR_TIMER_ID</GTKDOCLINK
> tid);</PRE
></TD
></TR
></TABLE
><P
>Destroys the specified timer. Note that it is possible for there to be one
or more undelivered timer events already in the queue when <A
HREF="nano-x-misc.html#GRDESTROYTIMER"
>GrDestroyTimer</A
>()
is called, and they will still be delivered anyway.</P
><P
></P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN3848"
></A
><P
></P
><TABLE
BORDER="0"
WIDTH="100%"
BGCOLOR="#FFD0D0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="RIGHT"
VALIGN="TOP"
><TT
CLASS="PARAMETER"
><I
>tid</I
></TT
>&nbsp;:</TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
> the ID of the timer to destroy</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><BR
CLEAR="all"><BR><TABLE
WIDTH="100%"
BORDER="0"
BGCOLOR="#000000"
CELLPADDING="1"
CELLSPACING="0"
><TR
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="left"
><A
HREF="nano-x-selections.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>&#60;&#60;&#60; Previous Page</B
></FONT
></A
></TD
><TD
WIDTH="25%"
BGCOLOR="#0000C0"
ALIGN="center"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
><A
HREF="index.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Home</B
></FONT
></A
></B
></FONT
></TD
><TD
WIDTH="25%"
BGCOLOR="#00C000"
ALIGN="center"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
><A
HREF="libnano-x.html"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>Up</B
></FONT
></A
></B
></FONT
></TD
><TD
WIDTH="25%"
BGCOLOR="#C00000"
ALIGN="right"
>&nbsp;</TD
></TR
><TR
><TD
COLSPAN="2"
ALIGN="left"
><FONT
COLOR="#FFFFFF"
SIZE="3"
><B
>selections</B
></FONT
></TD
><TD
COLSPAN="2"
ALIGN="right"
>&nbsp;</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>